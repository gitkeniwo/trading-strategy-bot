"""
Data models for stock data and trading signals.

This module defines Pydantic models for:
- StockData: Historical price data with calculated moving averages
- Signal: Buy signal information (Signal 1 or Signal 2)
- SignalState: Persistent state for tracking signals across runs
"""

from datetime import datetime
from enum import Enum
from typing import Optional, Union

from pydantic import BaseModel, Field


class SignalType(str, Enum):
    """Type of buy signal."""

    SIGNAL_1 = "signal_1"  # 15% below MA120
    SIGNAL_2 = "signal_2"  # 20% below Signal 1 price


class StockData(BaseModel):
    """Stock price data with calculated indicators."""

    symbol: str
    name: str
    current_price: float
    ma120: float  # 120-day moving average
    timestamp: datetime
    days_of_data: int = Field(description="Number of days of historical data available")

    @property
    def ma120_deviation(self) -> float:
        """Calculate percentage deviation from MA120."""
        return ((self.current_price - self.ma120) / self.ma120) * 100

    @property
    def is_below_ma120_threshold(self) -> bool:
        """Check if price is 15% or more below MA120 (Signal 1 condition)."""
        return self.current_price <= self.ma120 * 0.85


class Signal(BaseModel):
    """Trading signal generated by the strategy."""

    signal_type: SignalType
    symbol: str
    name: str
    current_price: float
    ma120: float
    ma120_deviation_pct: float
    position_size_pct: float = Field(description="Position size as percentage (0.20 = 20%)")
    timestamp: datetime

    # Signal 2 specific fields
    signal_1_price: Optional[float] = None
    signal_2_trigger_price: Optional[float] = None

    @property
    def position_size_display(self) -> str:
        """Display position size as percentage string."""
        return f"{int(self.position_size_pct * 100)}%"


class FetchError(BaseModel):
    """
    Error information when data fetch fails.

    Contains details about which provider failed and why.
    """

    symbol: str
    name: str
    provider: str
    error_message: str
    timestamp: datetime = Field(default_factory=datetime.now)


class SignalState(BaseModel):
    """
    Persistent state for tracking signals.

    This is saved to signals.json and committed to the repository.
    """

    symbol: str
    signal_1_triggered: bool = False
    signal_1_price: Optional[float] = None
    signal_1_date: Optional[str] = None
    signal_2_triggered: bool = False
    signal_2_price: Optional[float] = None
    signal_2_date: Optional[str] = None

    @property
    def signal_2_trigger_price(self) -> Optional[float]:
        """Calculate the price that would trigger Signal 2."""
        if self.signal_1_price is not None:
            return self.signal_1_price * 0.80
        return None

    def should_reset(self) -> bool:
        """
        Check if state should be reset.

        Reset logic: After Signal 2 fires, reset to allow future Signal 1 triggers.
        """
        return self.signal_2_triggered

    def reset(self):
        """Reset the signal state."""
        self.signal_1_triggered = False
        self.signal_1_price = None
        self.signal_1_date = None
        self.signal_2_triggered = False
        self.signal_2_price = None
        self.signal_2_date = None
